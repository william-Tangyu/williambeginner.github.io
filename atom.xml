<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>william&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yublog.com/"/>
  <updated>2020-09-23T09:14:50.005Z</updated>
  <id>http://yublog.com/</id>
  
  <author>
    <name>william</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>客户端储存</title>
    <link href="http://yublog.com/2020/05/22/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%82%A8%E5%AD%98/"/>
    <id>http://yublog.com/2020/05/22/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%82%A8%E5%AD%98/</id>
    <published>2020-05-21T16:00:00.000Z</published>
    <updated>2020-09-23T09:14:50.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h3><p>cookie是http协议下，服务端或者脚本可以维护客户端信息的一种方式。在H5之前，cookie是主要的存储方式，cookie可以兼容到包括ie6以上的所有浏览器。Cookie数据会带到请求头的cookie字段里面，通过Document对象的cookie属性可以实现cookie操作。但每次同主域名的请求中，都会传递数据，增加了网络请求的数据量，并且造成主域的污染。同时，cookie在不同浏览器上数量和大小都有限制。<br>cookie使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var cookie &#x3D; &#123;</span><br><span class="line">        &#x2F;**设置cookie </span><br><span class="line">         ** name 标识</span><br><span class="line">         ** value 值</span><br><span class="line">         ** options &#123;</span><br><span class="line">         **   &#39;path&#39;: &#39;访问路径&#39;,</span><br><span class="line">         **   &#39;domain&#39; : &#39;域名&#39;,</span><br><span class="line">         **   &#39;expire&#39; : 过期时间</span><br><span class="line">         **   &#39;secure&#39; : 安全 设置后只能通过https来传递cookie</span><br><span class="line">         **   &#39;httpOnly&#39; : 服务器可访问cookie,禁止客户端代码（js）修改该值 默认是 **true**</span><br><span class="line">         **   &#39;overwrite&#39; : 一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是**false**). </span><br><span class="line">         &#125;</span><br><span class="line">         **&#x2F;</span><br><span class="line">        setCookie : function(name,value,options)&#123;</span><br><span class="line">          var options &#x3D; options ? options : &#123;&#125;,</span><br><span class="line">              path &#x3D; options.path ? options.path : &#39;&#x2F;&#39;,</span><br><span class="line">              domain &#x3D; options.domain ? options.domain : document.domain,</span><br><span class="line">              time &#x3D; options.expire ? (new Date().getTime() + options.expire * 1000) : &#39;&#39;,</span><br><span class="line">              expire &#x3D; new Date(time).toUTCString();</span><br><span class="line">          document.cookie &#x3D; encodeURIComponent(name) + &quot;&#x3D;&quot;+ encodeURIComponent(value) + &quot;;expires&#x3D;&quot; + expire + </span><br><span class="line">                            &quot;;domain&#x3D;&quot; + domain + &quot;;path&#x3D;&quot; + path;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;获取cookie</span><br><span class="line">        getCookie: function(name)&#123;</span><br><span class="line">          var arr,</span><br><span class="line">              reg&#x3D;new RegExp(&quot;(^| )&quot;+name+&quot;&#x3D;([^;]*)(;|$)&quot;);</span><br><span class="line">          if(arr&#x3D;document.cookie.match(reg))&#123;</span><br><span class="line">             console.log(arr);</span><br><span class="line">             return unescape(arr[2]);</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">          </span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;移除cookie</span><br><span class="line">        removeCookie: function(name)&#123;</span><br><span class="line">          var val &#x3D; this.getCookie(name);</span><br><span class="line">          if(val !&#x3D; null)&#123;</span><br><span class="line">            this.setCookie(name,val, &#123;</span><br><span class="line">              expire : - 1</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>设置cookie的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function setCookie(name,value,options&#x3D;&#123;&#125;)&#123;</span><br><span class="line">    let cookieData &#x3D; &#96;$&#123;name&#125;&#x3D;$&#123;value&#125;;&#96;;</span><br><span class="line">    for(let key in options)&#123;</span><br><span class="line">        let str &#x3D; &#96;$&#123;key&#125;&#x3D;$&#123;options[key]&#125;;&#96;;</span><br><span class="line">        cookieData +&#x3D; str;</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie &#x3D; cookieData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cookie的生命周期是根据设置值得expire的时间来控制的，其适用范围需要根据前后端进行传递的数据（比如用户的登录状态）来判断。</p><h3 id="2-本地缓存localStorage和sessionStorage"><a href="#2-本地缓存localStorage和sessionStorage" class="headerlink" title="2.本地缓存localStorage和sessionStorage"></a>2.本地缓存localStorage和sessionStorage</h3><p>sessionStorage和localStorage是html5新引进的新特性。localStorage是存储在用户本地的浏览器上，不像cookie一样携带在http请求头部的字段里面，这有效的节约了带宽。localStorge同样也采用了同源策略对存储的容量进行了限制，一般限制为同一域名5M，并且不同域名的数据不能相互访问。<br>localStorage的存储周期为永久，只要开发者不手动删除，会一直存在；sessionStorage的存储周期为当前会话，数据会在浏览器会话（browsing session）结束时被清除。</p><p>localStorage的使用设置：<br>localstorage.length: 获取当前存储的key数量<br>localstorage.key(n):获取第n项的value值<br>localstorage.getItem(key):获取数据项指定key的value<br>localstorage.setItem(key,value):设置对应key的value（如果数据项中已存在该key，则更新value）<br>localstorage.remove(key):清除数据项指定key的value<br>localstorage.clear():清除存储的所有数据项<br>sessionStorage的使用方法与localStorage类似。需要注意的是：<br>localstorage存储的值只能是字符串的形式，当我们存储数据为引用对象的时候，会默认调用对象的toString方法，转化为字符串在存储。所以我们在存储数组时，存储的数据会将数据项以,隔开，解析的时候需要我们分解成为数组再操作。而对于对象，我们需要用JSON.stringify转化存储，获取数据后再用JSON.parse转化为对象<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.data &#x3D; JSON.stringify(data);    &#x2F;&#x2F; 进行编码储存</span><br><span class="line">var data &#x3D; JSON.parse(localStorage.data);    &#x2F;&#x2F; 将其取出</span><br></pre></td></tr></table></figure></p><h3 id="3-离线缓存application-cache"><a href="#3-离线缓存application-cache" class="headerlink" title="3.离线缓存application cache"></a>3.离线缓存application cache</h3><p>应用程序缓存，是从浏览器的缓存中分出的一块缓存区，要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。application cache通过mainfest文件指定了缓存的资源，可以使我们的应用在断网的时候也能够使用。application cache的使用比较简单，只需要两步：服务器端需要维护一个manifest清单和Html标签用属性manifest引入文件。<br>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分：<br>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存<br>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存<br>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）<br>application cache的核心是applicationCache对象，该对象的status属性值用来表示应用缓存的当前状态：<br>0（UNCACHED） :  无缓存， 即没有与页面相关的应用缓存<br>1（IDLE） : 闲置，即应用缓存未得到更新<br>2 （CHECKING） : 检查中，即正在下载描述文件并检查更新<br>3 （DOWNLOADING） : 下载中，即应用缓存正在下载描述文件中指定的资源<br>4 （UPDATEREADY） : 更新完成，所有资源都已下载完毕<br>5 （IDLE） :  废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存</p><h3 id="4-localStorage和sessionStorage和cookie相同点与差异性"><a href="#4-localStorage和sessionStorage和cookie相同点与差异性" class="headerlink" title="4.localStorage和sessionStorage和cookie相同点与差异性"></a>4.localStorage和sessionStorage和cookie相同点与差异性</h3><p>相同点：<br>localStorage和sessionStorage和cookie都有同源限制（请求响应的协议、域名和端口都相同则为同源，否则为跨源/跨域），存储的内容都会转为字符串格式，都有存储大小的限制。<br>三者之间的差异性：<br>localStorage存储的数据是永久性的，除非可以删除，否则会一直保留在电脑上；<br>localStorage的作用域是限定在文档源（document origin）。文档源通过协议、主机名以及端口三者来确定；<br>localStorage支持storage事件；</p><p>sessionStorage存储的有效期与浏览器标签页是一致的，一旦标签页关闭，则数据也会被删除；<br>sessionStorage作用域也是文档源，但还被限定在窗口中，即页面私有，如果同源的文档在不用的浏览器标签页中，那么他们间是无法共享数据的；<br> sessionStorage不支持storage事件；</p><p> 浏览器会主动存储接收到的 set-cookie 头信息的值，也会在每次请求的时候主动组织所有域下的cookie到请求头 cookie 中，发送给服务器端；<br> cookie可以设置 http-only 属性为 true 来禁止客户端代码（js）修改该值；<br>cookie可以设置有效期 (默认浏览器关闭自动销毁)(不同浏览器有所不同)；<br>cookie同域下个数有限制，最好不要超过50个(不同浏览器有所不同)；<br>单个cookie内容大小有限制，最好不要超过4000字节(不同浏览器有所不同)；</p><p>总结来说，浏览器的缓存在我们优化页面的时候很有用，特别是在移动端的时候。我们可以用localstorage来存储一些ajax请求的数据，或者一些经常不变的数据，如页面的bar数据等等，可以在结果没有返回的时候先用旧的数据进行填充，避免页面无数据状态过长。同时我们可以利用离线存储的功能来对一些公共的或者常用的js/css文件进行缓存到本地，避免用户网络访问请求，从而节约带宽并且提升网页加载速度。</p>]]></content>
    
    <summary type="html">
    
      客户端储存的出现是为了解决http协议为无状态路的协议，无法记住用户的状态的问题。客户端数据存储赋予浏览器快速访问数据的能力，从而节省网络流量并减轻浏览器的压力，同时使离线应用程序得以真正实现。客户端储存需遵守同源策略，只能读取对应页面的储存数据，不能读取不同站点页面的数据。
    
    </summary>
    
    
      <category term="Web前端" scheme="http://yublog.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yublog.com/categories/Web%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://yublog.com/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yublog.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BOM总结</title>
    <link href="http://yublog.com/2020/04/29/BOM%E6%80%BB%E7%BB%93/"/>
    <id>http://yublog.com/2020/04/29/BOM%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-28T16:00:00.000Z</published>
    <updated>2020-05-18T12:25:12.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-浏览器对象模型"><a href="#1-浏览器对象模型" class="headerlink" title="1.浏览器对象模型"></a>1.浏览器对象模型</h2><p>BOM是指浏览器对象模型，它是对一系列在浏览器环境中使用对象的统称，这些对象提供了访问浏览器的功能。</p><p>在BOM对象中，window对象是最顶层对象，在浏览器环境中它是一个Global全局对象，其它对象（如：DOM对象）对是这个对象的属性（子对象）。BOM对象是与内容无关，主要用于管理浏览器窗口及窗口之间的通讯。</p><h2 id="2-BOM中的对象"><a href="#2-BOM中的对象" class="headerlink" title="2.BOM中的对象"></a>2.BOM中的对象</h2><h3 id="2-1-window对象"><a href="#2-1-window对象" class="headerlink" title="2.1 window对象"></a>2.1 window对象</h3><p>window对象对象表示一个浏览器窗口或一个frame框架，它处于对象层次的最顶端，它提供了处理浏览器窗口的方法和属性。</p><p>window对象是浏览器对象中的默认对象，所以可以隐式地引用window对象的属性和方法。在浏览器环境中，添加到window对象中的方法、属性等，其作用域都是全局的。JavaScript中的标准内置对象，在浏览器环境中也是做为window的方法和属性出现的。<br>以下代码等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.alert();</span><br><span class="line">&#x2F;&#x2F;相等</span><br><span class="line">alert();</span><br></pre></td></tr></table></figure><p>window常用的方法有：<br>-window.open(url,target,specs,replace) 打开新窗口其中url表示新窗口的地址；target表示新窗口的打开方式，其有两个值，blank表示新窗口打开，self表示当前窗口打开；specs表示新窗口的规格；replace代表替换当前窗口的新网址；<br>-window.close ()关闭当前窗口</p><p>window常用事件：<br>-window.onload 和window.onunload （加载和卸载事件，在页面完全加载和完全卸载之后触发）<br>-window.onscroll (滚动事件，在页面滚动的时候触发)<br>-window.onresiz (窗口改变事件，改变窗口尺寸时触发)</p><h3 id="2-2-navigator对象"><a href="#2-2-navigator对象" class="headerlink" title="2.2 navigator对象"></a>2.2 navigator对象</h3><p>navigator是指浏览器对象，该对象提供了当前正在使用的浏览器的信息。navigator对象中的属性是只读的，在W3C在HTML5标准中，对该对象进行了规范。由于浏览器的不同，该对象的具体值可能有所区别。</p><h3 id="2-3-screen对象"><a href="#2-3-screen对象" class="headerlink" title="2.3 screen对象"></a>2.3 screen对象</h3><p>screen对象中包含了用户显示器屏幕相关信息。通过该对象，可以访问用户显示器屏幕宽、高、色深等信息。</p><h3 id="2-4-history对象"><a href="#2-4-history对象" class="headerlink" title="2.4 history对象"></a>2.4 history对象</h3><p>history对象来保存浏览器历史记录信息，也就是用户访问的页面。浏览器的前进与后退功能本质上就是history的操作。history对象记录了用户浏览过的页面，通过该对象提供的API可以实现与浏览器前进/后退类似的导航功能。history常用方法：<br>-history.back() 返回上一页<br>-history.forward() 下一页<br>-history.go(x)  参数为正数，前进x页；参数为负数，后退x页<br>-history.length 历史记录个数</p><h3 id="2-5-location对象"><a href="#2-5-location对象" class="headerlink" title="2.5 location对象"></a>2.5 location对象</h3><p>location是一个静态对象，该对象是对当前窗口URL地址的解析。该对象提供了可以访问URL中不同部分的信息属性，通过location对象也可以实现页面或锚点跳转等功能。一般包含以下信息：<br>-host：主机信息，域名+端口<br>-hostname：主机地址或者域名<br>-href：完整的地址<br>-port：端口<br>-pathname：路径<br>-protocol：http或者https协议<br>-hash：代表了地址栏后#后边的内容，在CSS中叫锚点<br>-search：代表了地址栏后？后边的内容，获取get方式提交过来的数据<br>-reload：刷新</p><h2 id="3-前端路由"><a href="#3-前端路由" class="headerlink" title="3.前端路由"></a>3.前端路由</h2><p>路由（routing）是指从分组从源到目的地时，决定端到端路径的网络范围的进程。<br>前端路由通常是指根据路径决定前端显示的视图<br>路由通常有两种规则：<br>1.完整匹配，url本身是什么就匹配什么  /index == /index<br>2.规则中，有一部分是可变的（存在:的情况就需要分成一段一段去匹配 /index/:page == /index/index</p>]]></content>
    
    <summary type="html">
    
      BOM浏览器对象模型（Browser Object Model）BOM对象是在Web中使用JavaScript的核心，该对象提供了与浏览器交互相关对象结构。BOM由多个子对象组成，其核心为window对象，它是BOM的顶层对象，表示在浏览器环境中的一个全局的顶级对象，所有在浏览器环境中使用的对象都是window对象的子对象。
    
    </summary>
    
    
      <category term="Web前端" scheme="http://yublog.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yublog.com/categories/Web%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://yublog.com/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yublog.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM总结</title>
    <link href="http://yublog.com/2020/04/23/DOM%E6%80%BB%E7%BB%93/"/>
    <id>http://yublog.com/2020/04/23/DOM%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-09-23T09:05:01.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript-的组成部分"><a href="#javascript-的组成部分" class="headerlink" title="javascript 的组成部分"></a>javascript 的组成部分</h2><ul><li>DOM (document object model) 文档对象模型</li><li>BOM (browers object model) 浏览器对象模型</li><li>ECMAScript JavaScript 的核心</li></ul><p>-！[DOM树] (<a href="https://upload-images.jianshu.io/upload_images/16749538-64b1ae6106efded7.png" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/16749538-64b1ae6106efded7.png</a>)</p><h2 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h2><h3 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h3><ol><li>元素节点：每个 HTML元素    </li><li>属性节点：HTML元素的属性</li><li>文本节点：HTML元素内的文本    </li><li>注释节点：注释 <!----></li><li>文档节点：整个文档document    </li></ol><h3 id="节点类型-—-nodeType"><a href="#节点类型-—-nodeType" class="headerlink" title="节点类型 — nodeType"></a>节点类型 — nodeType</h3><ul><li>元素节点：1    </li><li>属性节点：2</li><li>文本节点：3    </li><li>注释节点：8</li><li>文档节点：9</li></ul><h3 id="节点名称-—-nodeName打印结果"><a href="#节点名称-—-nodeName打印结果" class="headerlink" title="节点名称 — nodeName打印结果"></a>节点名称 — nodeName打印结果</h3><ul><li>元素节点：与标签名相同    </li><li>文本节点：为#text    </li><li>注释节点：为#comment</li><li>文档节点：为#document </li></ul><h2 id="DOM关系"><a href="#DOM关系" class="headerlink" title="DOM关系"></a>DOM关系</h2><h3 id="查找子级"><a href="#查找子级" class="headerlink" title="查找子级"></a>查找子级</h3><pre><code>- childNodes 子节点（包含所有节点：文本节点、注释节点、元素节点等）- children 子元素 （只包含元素节点）- firstChild 第0个子节点- firstElementChild 第0个子元素- lastChild 最后一个子节点- lastElementChild 最后一个子元素</code></pre><h3 id="查找兄弟级"><a href="#查找兄弟级" class="headerlink" title="查找兄弟级"></a>查找兄弟级</h3><pre><code>- nextSibling 下一个兄弟节点- nextElementSibling 下一个兄弟元素- previousSibling 上一个兄弟节点- previousElementSibling 上一个兄弟元素</code></pre><h3 id="查找父级"><a href="#查找父级" class="headerlink" title="查找父级"></a>查找父级</h3><pre><code>- parentNode 父节点- offsetParent 定位父级</code></pre><h3 id="nodeList和HTMLCollection的区别"><a href="#nodeList和HTMLCollection的区别" class="headerlink" title="nodeList和HTMLCollection的区别"></a>nodeList和HTMLCollection的区别</h3><p>nodeList由childNodes和querySelectorAll方法得到，可以使用forEach方法依次循环，而HTMLCollection由children、getElementsByTagName和getElementsByClassName得到，不能使用forEach方法；另外，HTMLCollection每次调用都会动态获取，即获取的内容跟随页面的变化而变化，nodeList中chilNodes可以动态获取，而querySelectorAll不能动态获取，每次获取的都是初始的内容。</p><h2 id="DOM-属性操作"><a href="#DOM-属性操作" class="headerlink" title="DOM 属性操作"></a>DOM 属性操作</h2><p>. 和 [] 都是ECMAScript中对对象的合法属性（W3C规定的元素属性）的操作，对象属性的值会被存在内存中, 想要直接获取存在文档中属性，或者想把一个属性设置在文档中我们需要使用DOM 的属性操作：</p><ul><li>el.attributes 元素所有属性的集合</li><li>el.getAttribute(“attr”) 获取属性</li><li>el.setAttribute(“attr”,”val”) 设置属性</li><li>el.removeAttribute(“attr”) 移出属性</li><li>el.hasAttribute(“attr”) 判断是否有这个属性<br>只要操作了innerHTML，元素的所有子元素上，存在内存中的事件和相关的属性都会丢失。如果希望元素的某些属性在操作了父级的innerHTML之后还存在，就需要把这个属性加在 DOM 中。存在内存中的数据可以是任意类型，但利用Attribute系列存在文档中，只能是String类型。</li></ul><h2 id="data-自定义属性"><a href="#data-自定义属性" class="headerlink" title="data 自定义属性"></a>data 自定义属性</h2><ul><li>在标签中定义data自定义属性：data-key=”value”;</li><li>在js操作该元素的 data 自定义属性：el.dataset<ul><li>获取：el.dataset.key</li><li>设置: el.dataset.key = “value”</li></ul></li></ul><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>语法：element document.createElement(“tagName”); 创建一个节点<br>参数：tagName 标签名称<br>返回值：创建好的节点</p><h3 id="向页面中添加节点"><a href="#向页面中添加节点" class="headerlink" title="向页面中添加节点"></a>向页面中添加节点</h3><ul><li>el.appendChild(node)  在元素的末尾添加一个子级</li><li>el.insertBefore(newNode,oldNode) 在 oldNode 前边添加入 newNode </li><li>在使用 appendChild 和 insertBefore时，如果添加是一个页面上已经存在的节点，会先从原位置删除，然后在添加到新的位置去。</li></ul><h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><ul><li>parent.replaceChild(newNode,oldNode) 替换子元素</li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul><li>el parent.removeChild(el) 删除掉某个子元素</li><li>node.remove();</li></ul><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><ul><li>node.cloneNode(deep) <ul><li>deep: 默认为false</li><li>deep 为 true, 克隆元素及属性，以及元素的内容和后代，但不会克隆事件</li><li>deep 为 false, 只克隆元素本身，及它的属性</li></ul></li></ul><h2 id="元素的尺寸获取"><a href="#元素的尺寸获取" class="headerlink" title="元素的尺寸获取"></a>元素的尺寸获取</h2><ul><li><p>offset</p><ul><li>offsetWidth  可视宽度 width+padding+border</li><li>offsetHeight 可视高度 height+padding+border</li><li>offsetLeft   距离定位父级的left坐标 </li><li>offsetTop    距离定位父级的top坐标</li></ul></li><li><p>client</p><ul><li>clientWidth  可视宽度 - border</li><li>clientHeight 可视高度 - border</li><li>clientTop    上边框宽度</li><li>clientLeft   左边框宽度 </li></ul></li><li><p>scroll</p><ul><li>scrollWidth   元素内容宽度，如果内容宽度小于元素宽度，scrollWidth = 元素宽度</li><li>scrollHeight  元素内容高度，如果内容高度小于元素高度，scrollHeight = 元素高度</li><li>scrollLeft    左右滚动距离</li><li>scrollTop     上下滚动距离</li></ul></li><li><p>getBoundingClientRect()（不兼容IE）</p><ul><li><p>left   元素左侧距离可视区左侧距离</p></li><li><p>top    元素顶部距离可视区顶部距离</p></li><li><p>right  元素右侧距离可视区左侧距离</p></li><li><p>bottom 元素底部距离可视区顶部距离</p></li><li><p>width  可视宽度 </p></li><li><p>height 可视高度</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>创建完元素后，把元素相关的属性和事件都添加好之后，再放到DOM中，性能会好很多！</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。
    
    </summary>
    
    
      <category term="Web前端" scheme="http://yublog.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yublog.com/categories/Web%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://yublog.com/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yublog.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
